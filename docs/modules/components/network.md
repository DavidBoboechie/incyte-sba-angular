---
layout: default
title: Network Module
parent: Components
grand_parent: Modules
nav_order: 20
---

# Network Module

## Reference documentation

Please checkout the [reference documentation]({{site.baseurl}}components/modules/NetworkModule.html) auto-generated from source code.

Also checkout the official documentation of the [Vis.js network](https://visjs.github.io/vis-network/docs/network/) library and its [Github repository](https://github.com/visjs/vis-network).

## Features

This module includes a component which displays a network view (based on the [Vis.js network](https://visjs.github.io/vis-network/docs/network/) library). This view displays nodes and edges generated by one or several *providers* ([`NetworkProvider`]({{site.baseurl}}components/interfaces/NetworkProvider.html)). Each provider generates a *dataset* ([`NetworkDataset`]({{site.baseurl}}components/interfaces/NetworkDataset.html)) of nodes and edges, which are then merged into a single one before displaying the network.

![Network]({{site.baseurl}}assets/modules/network/network.png){: .d-block .mx-auto }

## Import

Import this module in your `app.module.ts`.

```ts
import { NetworkModule } from '@sinequa/components/network';

@NgModule({
  imports: [
    ...
    NetworkModule
```

## Network Component

The [`sq-network`]({{site.baseurl}}components/components/NetworkComponent.html) component is a facet component (See [Facet module](facet.html)), which is best used within a facet card:

```html
<sq-facet-card [title]="'Network'" [icon]="'fas fa-project-diagram'">
    <sq-network #facet [results]="results" [providers]="providers"></sq-network>
</sq-facet-card>
```

The component primarily requires a `providers` list as input ([`NetworkProvider`]({{site.baseurl}}components/interfaces/NetworkProvider.html) objects), which generate the data displayed in the network. The `results` input is essentially used to refresh the providers when new results come in.

## Network Providers

The [`NetworkProvider`]({{site.baseurl}}components/interfaces/NetworkProvider.html) interface contains the following fields and methods:

- `active: boolean`: Whether or not the provider is active (if inactive, it will not provide empty datasets of nodes and edges)
- `getProvider(): Subject<NetworkDataset>`: Returns the Subject of this provider. The subject is an event emitter which can provide a new dataset at any time.
- `getData()`: Typically called on initialization, or when new results come in, to trigger a new Dataset to be emitted by the provider (synchronously or not).
- `onDatasetsMerged(dataset: NetworkDataset)`: A method called after the datasets provided by all providers have been merged into a single dataset
- `onNodesInserted(nodes: Node[])`: A method called after the dataset is filtered (to keep only visible nodes) and passed to Vis for rendering
- `onNodeClicked(node?: Node)`: A method called when ANY node is cliked in the rendered view of the network
- `getProviderActions(): Action[]`: A method called to retrieve the list of action for this provider
- `getNodeActions(node: Node): Action[]`: A method called to retrieve the list of action for a given node, and this provider.
- `onDestroy()`: A method called when the providers are discarded. Can be use to cancel subscriptions.

This interface is implemented by a number of pre-packaged providers documented below. Developers are of course free to develop their own providers to customize how the network component works.

Providers require as inputs some *types* for the nodes and edges. These types are respectively [`NodeType`]({{site.baseurl}}components/interfaces/NodeType.html) and [`EdgeType`]({{site.baseurl}}components/interfaces/EdgeType.html) objects. These types determine the visual appearances (color, size, etc.) of the nodes and edges, thanks to a wide range of options available in the [Vis.js](https://visjs.github.io/vis-network/docs/network/) library.

Rather than creating providers and node types manually, the [`ProviderFactory`]({{site.baseurl}}components/injectables/ProviderFactory.html) can be injected into your app in order to easy generate the objects and configuration you need in your specific project:

```ts
import { ProviderFactory } from '@sinequa/components/network';

@Component({
  ...
})
export class MyComponent {

  constructor(
    ...
    public providerFactory: ProviderFactory
  )
```

### Records Provider

The class [`RecordsProvider`]({{site.baseurl}}components/classes/RecordsProvider.html) provides nodes that are generated from a list of [`Record`]({{site.baseurl}}components/interfaces/Record.html) objects ("record" is a generic term for the content of a Sinequa index, returned in the form of `Record` objects by the query web service).

Additionally, the provider can generate nodes and edges for the **properties** contained in that record. For example, if a record has "person" entities as a property, each of these "person" entity can be displayed as a property linked to the record:

```ts
// Create a standard "document" node type
const doc = providerFactory.createRecordNodeType();
// Create a standard "person" node type
const person = providerFactory.createPersonNodeType();

// Create an edge type for the "person" property of the "document" node
const struct = providerFactory.createStructuralEdgeTypes(doc, {person: person}, "oninsert", "all");

// Create a provider that provides document nodes with their structural neighbors, given a list of record objects
const provider = providerFactory.createRecordsProvider(doc, struct, records);
```

![Record provider]({{site.baseurl}}assets/modules/network/records-provider.png){: .d-block .mx-auto }

### Selected Records Providers

The [`SelectedRecordsProvider`]({{site.baseurl}}components/classes/SelectedRecordsProvider.html) is a direct extension of [`RecordsProvider`]({{site.baseurl}}components/classes/RecordsProvider.html). The difference is that the provider listens to the [`SelectionService`]({{site.baseurl}}components/injectables/SelectionService.html) (See [Selection module](selection.html)) and provides record nodes from the list of selected records.

This provider lets you easily see the common properties of two or more selected records.

```ts
// Create a standard "document" node type
const doc = providerFactory.createRecordNodeType();
// Create a standard "person" node type
const person = providerFactory.createPersonNodeType();

// Create an edge type for the "person" property of the "document" node
const struct = providerFactory.createStructuralEdgeTypes(doc, {person: person}, "oninsert", "all");

// Create a provider that provides document nodes with their structural neighbors, from the list of selected records
const provider = providerFactory.createSelectedRecordsProvider(doc, struct);
```

![Selected Record provider]({{site.baseurl}}assets/modules/network/selected-records-provider.png){: .d-block .mx-auto }

### Async Records Providers

The [`AsyncRecordsProvider`]({{site.baseurl}}components/classes/AsyncRecordsProvider.html) is a direct extension of [`RecordsProvider`]({{site.baseurl}}components/classes/RecordsProvider.html). The difference is that the provider requires a [`Query`]({{site.baseurl}}core/classes/Query.html) object, which is used to fetch a list of records, and these records are then transformed into nodes (as described above).

```ts
// Create a custom "document" node type that displays an image (which URL is stored in the `sourcevarchar4` column)
const doc = providerFactory.createNodeType("doc", 
    providerFactory.createDynamicImageNodeOptions(
        (node: Node) => (node as RecordNode).record['sourcevarchar4']
    )
);

// Build a query to retrieve documents from a wikipedia index
const query = searchService.makeQuery();
query.text = "google";
query.addSelect("treepath:=/Web/Wiki/");
query.addSelect("sourcestr4:=human");
query.pageSize = 5;

// Create a provider that provides document nodes obtained from a query
const provider = providerFactory.createAsyncRecordsProvider(doc, [], query);
```

![Async Record provider]({{site.baseurl}}assets/modules/network/async-records-provider.png){: .d-block .mx-auto }

### Aggregation Provider

The [`AggregationProvider`]({{site.baseurl}}components/classes/AggregationProvider.html) provides nodes and edges generated from an *aggregation*. Aggregations are computed by the Sinequa engine based on the content of one column (or more) of an index. Aggregation are typically used to compute the content of facets (See [Facet Module](facet.html)).

The aggregation provider can be used to generate different types of relations between metadata:

- **Statistical relations**: In this case, we use **cross-aggregations** to count the number of records which contain two values of metadata. For example, we can count how many documents both have `docformat=pdf` and `author=John Doe`. The most frequent pairs of metadata are translated into edges between these metadata.
- **Proximity relations**: In this case, we use aggregations to count the number of **cooccurence entities** stored within a specific column. A cooccurrence entity stores the occurrence of two other entities within a short range of text, like in the sentence *"**Larry Page** works at **Google**"*, which could be normalized as `(LARRY PAGE)#(GOOGLE)`. The cooccurrences are then translated as edges between each entity.
- **Semantic relations**: In this case, we use aggregations to count the number of **semantic entities** stored within a specific column. A semantic entity stores the typed relation between two entities, like in the sentence *"**Larry Page** is an engineer who **works at** the company **Google**"* (unlike in the previous example, "work at" can be normalized as a type of relation between the two entities, so that this sentence could be stored as `(GOOGLE)->(EMPLOYS)->(LARRY PAGE)`). Then this relation between the two entities can be visualized as a directed typed edge.

Assuming the entities are properly extracted from documents, normalized and stored in columns of the index, the following example describe how to use the [`AggregationProvider`]({{site.baseurl}}components/classes/AggregationProvider.html) to produce different types of network visualizations.

Note that in all cases, **aggregations are computed in the context of the current query of the [`SearchService`]({{site.baseurl}}components/injectables/SearchService.html)**, unless a different Query is passed to the provider as an option input. This means if you search for "Google", the top relations built by this provider should normally include companies like Google, and people like Larry Page.

#### **Statistical relations**

First we need to configure the cross-aggregation calculation on the server, in the **Query web service** (see [Server-side setup]({{site.baseurl}}gettingstarted/server-setup.html#apps)).

![Cross distribution configuration]({{site.baseurl}}assets/modules/network/cross-dist.png){: .d-block .mx-auto }
*Configuration for a cross-aggregation between the **company** and **person** columns*
{: .text-center }

```ts
// Create two standard node types for persons and companies
const person = providerFactory.createPersonNodeType();
const company = providerFactory.createCompanyNodeType();

// Create an edge type between these two node types
const edge = providerFactory.createAggregationEdgeType([company, person], "Company_Person")

// Create the provider, given the edge type
const provider = providerFactory.createAggregationProvider(edge);
```

![Cross distribution provider]({{site.baseurl}}assets/modules/network/cross-dist-provider.png){: .d-block .mx-auto }

Note that the size of each node is proportional to the width of adjacent edges, which itself reflects the "count" of each pair in the distribution (which is equal to the number of documents containing both metadata).

#### **Proximity relations**

First we need to configure the aggregation calculation on the server, in the **Query web service** (see [Server-side setup]({{site.baseurl}}gettingstarted/server-setup.html#apps)).

The aggregation must be computed for a column where cooccurrences are stored in the format `(VALUE 1)#(VALUE 2)`.

The code below is almost identical to the one above for statistical relations. The difference is that we are calling the `createCoocAggregationEdgeType()` method instead of `createAggregationEdgeType()`.

```ts
// Create two standard node types for persons and companies
const person = providerFactory.createPersonNodeType();
const company = providerFactory.createCompanyNodeType();

// Create an cooccurrence aggregation edge type between these two node types
const edge = providerFactory.createCoocAggregationEdgeType([company, person], "Company_Person_Cooc")

// Create the provider, given the edge type
const provider = providerFactory.createAggregationProvider(edge);
```

![Cooccurrence provider]({{site.baseurl}}assets/modules/network/cooccurrences.png){: .d-block .mx-auto }
