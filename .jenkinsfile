// ### Environment ###
properties([
	parameters([
		string(name:"SBA_VERSION",  defaultValue: "", description: "Version of sba", trim: true),
		string(name:"SBA_APP_LIST", defaultValue: "sba-sinequa-analytics-internal,sba-sesame", description: "App list to rebuild (comma separated)", trim: true),
		string(name:"SBA_NODE",    defaultValue: "${env.SBA_NODE}", description: "Execution node name", trim: true)
	]),
	disableConcurrentBuilds()
])

// Get mail parameters from jenkins env vars
url           = "${env.NPM_SERVER_URL}"
npm_user      = "${env.NPM_USER}"
npm_pass      = "${env.NPM_PASS}"
npm_mail      = "${env.NPM_MAIL}"
mailto        = "${env.NPM_MAILING_LIST}"
// default version number of the develop branch
developNumber = "${env.NPM_DEVELOP_NUMBER}"

// get job variables from job parameters
sba_version   = "${params.SBA_VERSION}"
sba_app_list  = "${params.SBA_APP_LIST}"

// .npmrc variables for verdaccio connection
scope  = "@sinequa"
fnpmrc = '.npmrc'
anpmrc = ["always-auth=true", "registry=${url}/", "scope=${scope}"]


// call a job to build an app
def build_app(sba_version, jobToBuild, branch) {
	stage("Build app ${jobToBuild}") {
		try {
			def enabled = Jenkins.instance.getItemByFullName(jobToBuild).isBuildable();
			def jobnamebranch = "${jobToBuild}/${branch}"
			echo "build app ${jobToBuild} in branch ${branch} with sba-internal version ${sba_version} ${jobnamebranch}"
			if (enabled) {
				def res = build job: jobnamebranch, wait : true, propagate : true, parameters: [string(name: 'SBA_VERSION', value: sba_version)]
			}
		} catch (err) {
			currentBuild.result = "FAILURE"
			sendMessage("#CC0000", "Build failed when building ${jobToBuild} in branch ${branch} with sba-internal version ${sba_version}")
			throw err
		}
	}
}

// set the sba_version variable with the version
// the version is calculated or is a parameter of the job
def set_sba_version(curBranch) {
	if (sba_version.length() == 0) {
		if ( env.BRANCH_NAME.contains("release") ) {
			sba_version = curBranch.split("%2F")[1].trim()
		} else {
			sba_version = developNumber
		}
	}
	echo "sba_version: ${sba_version}"
}

// get the branch name and the version number from the right jenkins variable 
def findBranchNumber() {
	def tmpBranch=""
	def theBranch=""
	// PR : 
	//   BRANCH_NAME: PR-8208
	//   CHANGE_TARGET: release/11.7.0
	// BRANCH
	//   BRANCH_NAME: develop
	//   BRANCH_NAME: release/11.7.0
	// return: release%2F11.7.0

	echo "Triggering job for branch ${env.BRANCH_NAME}"
	if (env.BRANCH_NAME.contains("PR-")) {
		tmpBranch = env.CHANGE_TARGET
	} else {
		tmpBranch = env.BRANCH_NAME
	}
	echo "tmpBranch: ${tmpBranch}"

	theBranch = tmpBranch.replace("/", "%2F")
	echo "Branch returned: ${theBranch}"
	return theBranch
}

// function to send an email to the authors of the commit
def sendMessage(color, specificMessage, logfile="") {
	echo "Message is: ${specificMessage}"
	if (!binding.hasVariable("AUTHOR_NAME")) {
		AUTHOR_NAME = ""
	}
	// https://jenkins.sinequa.com/env-vars.html/

	to = ""
	pbranch = env.BRANCH_NAME
	branch_link = pbranch
	if (pbranch.startsWith("PR-")) {
		branch_link += " https://github.sinequa.com/Product/ice/pull/" + pbranch.replace("PR-", "")
	}
	if ("${color}" == "#26cc00") {
		status = "OK"
	} else {
		status = "Failed"
		to = mailto
	}
	if ("${AUTHOR_NAME}" != "") {
		to = "${AUTHOR_NAME}" + ", " + to
	}
	// println("mailTo: ${to}")
	
	subject = "[${pbranch}] ${BUILD_TAG} ${status}"
	echo "Send email ${subject} to ${to}"
	
	header = "Commit on branch ${branch_link} from ${AUTHOR_NAME}\nJob ${BUILD_URL}/\n"
	message = "${header}\n${specificMessage}"
	
	if ("${status}" == "Failed" && logfile?.trim()) {
		log = bat (script: "type ${WORKSPACE}\\${logfile}",returnStdout: true)
		emailext(from: "build@sinequa.com",  to: "${to}", attachLog:true, subject: "${subject}", body: "${message}\n\n${log}")
	} else {
		emailext(from: "build@sinequa.com",  to: "${to}", attachLog:false, subject: "${subject}", body: "${message}\n\n")
	}
}

// build "as before"
def simple_build() {
	try {
		stage('Build Core')        {
			echo "npm run buildcore --if-present"
			bat  "npm run buildcore --if-present"
		}
		stage('Build Components')  {
			echo "npm run buildcomponents --if-present"
			bat  "npm run buildcomponents --if-present"
		}
		stage('Test Components')   {
			echo "npm run test components -- --watch=false"
			bat  "npm run test components -- --watch=false"
		}
		stage('Build Analytics')   {
			echo "npm run buildanalytics --if-present"
			bat  "npm run buildanalytics --if-present"
		}
		stage('Build HelloSearch') {
			echo "npm run buildhellosearch --if-present"
			bat  "npm run buildhellosearch --if-present"
		}
		stage('Build Vanilla')     {
			echo "npm run buildvanilla --if-present"
			bat  "npm run buildvanilla --if-present"
		}
		stage('Build Pepper')      {
			echo "npm run buildpepper --if-present"
			bat  "npm run buildpepper --if-present"
		}
	} catch (err) {
		currentBuild.result = "FAILURE"
		throw err
	}
}

// build sinequa core modules then start a list of apps (param of the job) to be build
def validation() {
	try {
		stage('Build Core')       {
			echo "npm run buildsqcore --sq_version=${sba_version} --if-present"
			bat  "npm run buildsqcore --sq_version=${sba_version} --if-present"
		}
		stage('Build Components') {
			echo "npm run buildsqcomponents --sq_version=${sba_version} --if-present"
			bat  "npm run buildsqcomponents --sq_version=${sba_version} --if-present"
		}
		stage('Build Analytics')  {
			echo "npm run buildsqanalytics --sq_version=${sba_version}  --if-present"
			bat  "npm run buildsqanalytics --sq_version=${sba_version}  --if-present"
		}
		
		echo "Build apps ${sba_app_list}"
		def applist = sba_app_list.split(',')
		// echo "applist: ${applist}"
		def nbapp = applist.size()
		def j = 0
		for (int i=0; i < nbapp ; i++) {
			j = i + 1
			// call the app job with the params: version and branch
			echo "  app ${j}/${nbapp}: ${applist[i]}"
			build_app(sba_version, applist[i], currentBranch)
		}
	} catch (err) {
		currentBuild.result = "FAILURE"
		throw err
	}
}

// function to check if we are in PR or another branch
def buildOrMerge() {
	def typeAction = ""
	if (env.BRANCH_NAME.contains("PR-")) {
		typeAction = "build"
	} else {
		typeAction = "merge"
	}
	return typeAction
}

// function to append lines to the end of a file
def appendFile(afile, what) {
	def content = ""
	def txt = ""
	try {
		if (fileExists(afile)) {
			content = readFile afile
			what.each {
				txt += it + "\n"
			}
			content += txt
			//echo "content: ${content}"
			writeFile file: afile, text: content
		}
	} catch (err) {
		currentBuild.result = "FAILURE"
		throw err
	}
}

node (params.SBA_NODE) {
	currentBuild.result = "SUCCESS"
	try {
		def currentBranch = findBranchNumber()
		set_sba_version(currentBranch)

		stage('Checkout'){
			// get the source code
			checkout scm
		}
		
		stage('Clean') {
			// delete dependency modules 
			def nmfolder = "node_modules"
			echo ".Rmdir /s /q ${nmfolder}"
			bat "if exist ${nmfolder} ( rmdir /s /q ${nmfolder} )"
			
			// clean the npm cache
			echo ".Cache clean force"
			bat "npm cache clean --force"
		}
		
		stage('Create user') {
			// create user for verdaccio
			bat "npm-cli-login -u ${npm_user} -p ${npm_pass} -e ${npm_mail} -r ${url} -s ${scope} --config-path ${fnpmrc}"
			// add connection infos in .npmrc file
			appendFile(fnpmrc, anpmrc)
			// check the connection
			bat "npm whoami"
		}
		
		stage('copyNpmrc') {
			// copy .npmrc file in sub project folder
			bat "xcopy ${fnpmrc} .\\projects\\core\\ /Y"
			bat "xcopy ${fnpmrc} .\\projects\\components\\ /Y"
			bat "xcopy ${fnpmrc} .\\projects\\analytics\\ /Y"
		}
		
		stage('NPM Install') {
			// get the dependency modules
			bat "npm i"
		}
		
		// check if if we are in standard case of build or merge (case of PR)
		def action = buildOrMerge()
		if ("${action}" == "build") {
			// just make a build
			simple_build()
		} else {
			// validate the build before merge
			validation()
		}

	} catch (err) {
		currentBuild.result = "FAILURE"
		throw err
	}
}
